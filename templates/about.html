<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>About CFGI</title>
  </head>
  <body>
    {% extends "template.html" %}
    {% block content %}
    
    <h1> About CFGI </h1>
            <div align="right"><h5>Context-Free Languages</h5></div>
            <center>
            <h2>
            Context-Free Grammar</h2>
            </center>
            <br><br>
            <h3><font color="green">Subjects to be Learned</font></h3>
            <ul>
            <li>Context-Free Grammar
            </li><li>Context-Free Languages
            </li><li>Push Down Automata
            </li></ul>
            <h3><font color="green">Contents</font></h3>
            Earlier in the discussion of grammars we saw context-free grammars.
            They are grammars whose productions have the form 
            X -&gt; <img src="/static/images/alpha.gif"> , where X is a nonterminal and 
            <img src="/static/images/alpha.gif"> is a nonempty string of terminals 
            and nonterminals. 
            The set of strings generated by a context-free grammar is called a context-free
            language and context-free languages can describe many practically important
            systems. Most programming languages can be approximated by context-free grammar
            and compilers for them have been developed based on properties of context-free 
            languages. Let us define context-free 
            grammars and context-free languages here.
            <br><br>
            <b>
            Definition (Context-Free Grammar) : 
            </b>
            A 4-tuple G = &lt; V , <img src="/static/images/Sigma.gif"> , S , P &gt;
            is a <font color="red"><b>context-free grammar (CFG)</b></font> if
            V and <img src="/static/images/Sigma.gif"> are finite sets sharing no elements
            between them, S <img align="MIDDLE" src="/static/images/in.gif"> V is the start 
            symbol, and P is a finite set of productions of the form X -&gt; 
            <img src="/static/images/alpha.gif"> , where
            X <img align="MIDDLE" src="/static/images/in.gif"> V , and 
            <img src="/static/images/alpha.gif"> <img align="MIDDLE" src="/static/images/in.gif">
             ( V <img src="/static/images/cup.gif"> <img src="/static/images/Sigma.gif"> )<sup>*</sup> . 
            <br>
            A language is a <font color="red"><b>context-free language (CFL)</b></font> 
            if all of its strings are generated by a context-free grammar.
            
            <br>
            <br>
            <b>
            Example 1:
            </b>
            L<sub>1</sub> = { a<sup>n</sup>b<sup>n</sup> | n is a positive integer } 
            is a context-free language. For the following context-free grammar 
            G<sub>1</sub> = &lt; V<sub>1</sub> , <img src="/static/images/Sigma.gif">, S , 
            P<sub>1</sub> &gt; generates L<sub>1</sub> :
            <br>
            V<sub>1</sub> = { S } , <img src="/static/images/Sigma.gif"> = { a , b } and
            P<sub>1</sub> = { S -&gt; aSb , S -&gt; ab }.
            <br><br>
            <b>
            Example 2:
            </b>
            L<sub>2</sub> = { ww<sup>r</sup>| w <img align="MIDDLE" src="/static/images/in.gif"> 
            {a, b }<sup>+</sup> }  is a context-free language ,
            where w is a non-empty string and w<sup>r</sup> denotes the reversal of string w, 
            that is, w is spelled backward to obtain w<sup>r</sup> . For the following 
            context-free grammar 
            G<sub>2</sub> = &lt; V<sub>2</sub> , <img src="/static/images/Sigma.gif">, S , 
            P<sub>2</sub> &gt;
             generates L<sub>2</sub> :
            <br>
            V<sub>2</sub> = { S } , <img src="/static/images/Sigma.gif"> = { a , b } and
            P<sub>2</sub> = { S -&gt; aSa , S -&gt; bSb , S -&gt; aa , S -&gt; bb }.
            <br><br>
            <b>
            Example 3:
            </b>
            Let L<sub>3</sub> be the set of algebraic expressions involving identifiers x and y,
             operations + and * and left and right parentheses. Then L<sub>3</sub> is a context-free 
            language.
            For the following context-free grammar 
            G<sub>3</sub> = &lt; V<sub>3</sub> , <img src="/static/images/Sigma.gif"><sub>3</sub>, S , 
            P<sub>3</sub> &gt; generates L<sub>3</sub> :
            <br>
            V<sub>3</sub> = { S } , <img src="/static/images/Sigma.gif"><sub>3</sub>  
            = { x , y , ( , ) , + , * } and
            P<sub>3</sub> = { S -&gt; ( S + S ) , S -&gt; S*S , S -&gt; x , S -&gt; y }.
            <br><br>
            <b>
            Example 4:
            </b>
            Portions of the syntaxes of programming languages can be described by context-free
            grammars. For example 
            <br>
            { &lt; statement &gt; -&gt; &lt; if-statement &gt;  , &lt; statement &gt;  -&gt; &lt; 
            for-statement &gt;  , 
            &lt; statement &gt;  -&gt; &lt; assignment &gt;  , . . . ,
            &lt; if-statement &gt;  -&gt; if ( &lt; expression &gt;  ) &lt; statement &gt; ,
            &lt; for-statement &gt;  -&gt; for ( &lt; expression &gt;  ; &lt; expression &gt;  
            ; &lt; expression &gt;  )
            &lt; statement &gt;  , . . . , &lt; expression &gt;  -&gt; &lt; algebraic-expression &gt;  , 
            &lt; expression &gt;  
            -&gt; &lt; logical-expression &gt;  , . . . } .
            <br>
            <br>
            <br>
            <b>
            Properties of Context-Free Language
            </b>
            <br>
            <br>
            <b>Theorem 1:</b>
            Let L<sub>1</sub> and L<sub>2</sub> be context-free languages.
            Then L<sub>1</sub> <img src="/static/images/cup.gif"> L<sub>2</sub> , L<sub>1</sub>L<sub>2</sub> ,
            and L<sub>1</sub><sup>*</sup> are context-free languages.
            <br>
            <br>
            <b>Outline of Proof</b>
            <br>
            <br>
            This theorem can be verified by constructing context-free grammars
            for union, concatenation and Kleene star of context-free grammars as follows:
            <br>
            Let G<sub>1</sub> = &lt; V<sub>1</sub> , <img src="/static/images/Sigma.gif"> ,
            S<sub>1</sub> , P<sub>1</sub> &gt; and G<sub>2</sub> = &lt; V<sub>2</sub> , 
            <img src="/static/images/Sigma.gif"> ,
            S<sub>2</sub> , P<sub>2</sub> &gt; be context-free grammars generating L<sub>1</sub> and 
            L<sub>2</sub> , respectively.
            <br>
            Then for L<sub>1</sub> <img src="/static/images/cup.gif"> L<sub>2</sub> , first relabel symbols 
            of V<sub>2</sub> , if necessary, so that V<sub>1</sub> and V<sub>2</sub> don't share any 
            symbols. Then let S<sub>u</sub> be a symbol 
            which is not in V<sub>1</sub> <img src="/static/images/cup.gif"> V<sub>2</sub> .
            Next define V<sub>u</sub> = V<sub>1</sub> <img src="/static/images/cup.gif"> V<sub>2</sub> 
            <img src="/static/images/cup.gif"> { S<sub>u</sub> } and 
            P<sub>u</sub> = P<sub>1</sub> <img src="/static/images/cup.gif"> P<sub>2</sub>
            <img src="/static/images/cup.gif"> { S<sub>u</sub> -&gt; S<sub>1</sub> , 
            S<sub>u</sub> -&gt; S<sub>2</sub> } .
            <br>
            Then it can be easily seen that G<sub>u</sub> = &lt; V<sub>u</sub> , 
            <img src="/static/images/Sigma.gif"> ,
            S<sub>u</sub> , P<sub>u</sub> &gt; is a context-free grammar that generates the language 
            L<sub>1</sub> <img src="/static/images/cup.gif"> L<sub>2</sub> .
            <br>
            <br>
            Similarly for L<sub>1</sub>L<sub>2</sub> , first relabel symbols of V<sub>2</sub> , 
            if necessary, so that V<sub>1</sub> and V<sub>2</sub> don't share any symbols. 
            Then let S<sub>c</sub> be a symbol 
            which is not in V<sub>1</sub> <img src="/static/images/cup.gif"> V<sub>2</sub> .
            Next define V<sub>c</sub> = V<sub>1</sub> <img src="/static/images/cup.gif"> V<sub>2</sub> 
            <img src="/static/images/cup.gif"> { S<sub>c</sub> } and 
            P<sub>c</sub> = P<sub>1</sub> <img src="/static/images/cup.gif"> P<sub>2</sub>
            <img src="/static/images/cup.gif"> { S<sub>c</sub> -&gt; S<sub>1</sub>S<sub>2</sub> } .
            <br>
            Then it can be easily seen that G<sub>c</sub> = &lt; V<sub>c</sub> , 
            <img src="/static/images/Sigma.gif"> ,
            S<sub>c</sub> , P<sub>c</sub> &gt; is a context-free grammar that generates the language 
            L<sub>1</sub>L<sub>2</sub> .
            <br>
            <br>
            For L<sub>1</sub><sup>*</sup> , let S<sub>s</sub> be a symbol 
            which is not in V<sub>1</sub> . Then let P<sub>s</sub> = P<sub>1</sub> 
            <img src="/static/images/cup.gif"> { S<sub>s</sub> -&gt; S<sub>s</sub>S<sub>1</sub> ,
            S<sub>s</sub> -&gt; <img src="/static/images/Lambda.gif">  } .
            It can be seen that the grammar G<sub>s</sub> = &lt; V<sub>s</sub> , 
            <img src="/static/images/Sigma.gif"> ,
            S<sub>s</sub> , P<sub>s</sub> &gt; is a context-free grammar that generates the language 
            L<sub>1</sub><sup>*</sup> .
            <br>
            <br>
            <b>
            Pushdown Automata
            </b>
            <br>
            <br>
            Like regular languages which are accepted by finite automata, context-free
            languages are also accepted by automata but not finite automata. They need a little more 
            complex automata called pushdown automata.
            <br>
            Let us consider a context-free language a<sup>n</sup>b<sup>n</sup> .
            Any string of this language can be tested for the membership for the language 
            by a finite automaton if there is a memory such as a pushdown stack that can store 
            a's of a given input string. For example, as a's are read by the finite 
            automaton, 
            push them into the stack. 
            As soon as the symbol b appears stop storing a's and start popping a's one 
            by one every time a b is read.
            If another a (or anything other than b) is read after the first b, reject the string. 
            When all the symbols of the input string are read, check the stack.
            If it is empty, accept the string. Otherwise reject it.<br>
            This automaton behaves like a finite automaton except the following two points: First, 
            its next state is determined not only by the input symbol being read, but also 
            by the symbol at the top of the stack. Second, the contents of the stack can also 
            be changed 
            every time an input symbol is read. Thus its transition function specifies the new top of 
            the stack contents as well as the next state. 
            <br>
            <br>
            Let us define this new type of automaton formally. 
            <br><br>
            
            <!--
            <B>Pushdown Automaton</B>
            <BR>
            <BR>
            --->
            
            A <font color="red"><b>pushdown automaton</b></font> ( or <font color="red"><b>PDA</b></font> for short ) 
            is a 7-tuple M = &lt; Q , <img src="/static/images/Sigma.gif"> ,
            <img src="/static/images/Gamma.gif"> , q<sub>0</sub> , Z<sub>0</sub> , A , 
            <img src="/static/images/delta.gif"> &gt; , where 
            <br>
            Q is a finite set of states,
            <br>
            <img src="/static/images/Sigma.gif"> and
            <img src="/static/images/Gamma.gif"> are finite sets ( the input and stack alphabet, respectively ).
            <br>
            q<sub>0</sub> is the initial state, 
            <br>
            Z<sub>0</sub> is the initial stack symbol and it is a member of <img src="/static/images/Gamma.gif"> ,
            <br>
            A is  the set of accepting states 
            <br>
            <img src="/static/images/delta.gif"> is the transition function and 
            <br>
            <img src="/static/images/delta.gif"> : Q <img align="TOP" src="/static/images/times.gif"> 
            (<img src="/static/images/Sigma.gif"> <img src="/static/images/cup.gif"> 
            (<img src="/static/images/Lambda.gif"> } 
            <img align="TOP" src="/static/images/times.gif">
            <img src="/static/images/Gamma.gif">  -&gt; 2<sup> Q</sup> 
            <img align="TOP" src="/static/images/times.gif"> 
            <img align="TOP" src="/static/images/Gamma.gif"><sup>*</sup>.
            <br>
            <br><br>
            Thus <img src="/static/images/delta.gif">( p , a , X ) = 
            ( q , <img src="/static/images/alpha.gif"> ) means the following: 
            <br>
            The automaton moves from the current 
            state of p to the next state q when it sees an input symbol a at the input and X at the top 
            of the stack, and it replaces X with the string <img src="/static/images/alpha.gif"> 
            at the top of the stack.
            <br>
            <br>
            <b>Example 1 : </b>
            
            <br><br>
            Let us consider the pushdown automaton &lt; Q , <img src="/static/images/Sigma.gif"> ,
            <img src="/static/images/Gamma.gif"> , q<sub>0</sub> , Z<sub>0</sub> , A , 
            <img src="/static/images/delta.gif"> &gt; , where 
            Q = { q<sub>0</sub> , q<sub>1</sub> , q<sub>2</sub> } , 
            <img src="/static/images/Sigma.gif"> = { a , b } ,
            <img src="/static/images/Gamma.gif"> = { a , b , Z<sub>0</sub> } , 
            A = { q<sub>2</sub> } and let <img src="/static/images/delta.gif"> be as given in the following 
            table:
            <br>
            <br>
            <table border="" align="center" clospan="20">
            <tbody><tr>
            <th> State </th> <th>Input</th> <th> Top of Stack </th> <th>Move</th>
            </tr>
            <tr>
            <td> q<sub>0</sub>  </td> <td>a</td> <td> Z<sub>0</sub>  </td> <td>( q<sub>0</sub> , aZ <sub>0</sub> ) </td>
            </tr>
            <tr>
            <td> q<sub>0</sub>  </td> <td>a</td> <td> a  </td> <td>( q<sub>0</sub> , aa ) </td>
            </tr>
            <tr>
            <td> q<sub>0</sub>  </td> <td>b</td> <td> a  </td> <td>( q<sub>1</sub> , <img src="/static/images/Lambda.gif">  ) </td>
            </tr>
            <tr>
            <td> q<sub>1</sub>  </td> <td>b</td> <td> a  </td> <td>( q<sub>1</sub> , <img src="/static/images/Lambda.gif"> ) </td>
            </tr>
            <tr>
            <td> q<sub>1</sub>  </td> <td><img src="/static/images/Lambda.gif"></td> <td> Z<sub>0</sub> </td> <td> ( q<sub>2</sub> , Z<sub>0</sub>  ) </td>
            </tr>
            </tbody></table>
            <br>
            <br>
            This pushdown automaton accepts the language a<sup>n</sup>b<sup>n</sup> .
            To describe the operation of a PDA we are going to use a configuration of PDA.
            A <font color="red"><b>configuration</b></font> of a PDA M = &lt; Q , 
            <img src="/static/images/Sigma.gif"> ,
            <img src="/static/images/Gamma.gif"> , q<sub>0</sub> , Z<sub>0</sub> , A , 
            <img src="/static/images/delta.gif"> &gt; is a triple 
            ( q , x , <img src="/static/images/alpha.gif"> ) , where q is the state the PDA is currently in,
             x is the unread portion of the input string and <img src="/static/images/alpha.gif"> 
            is the current stack contents, where the input is read from left to right 
            and the top of the stack corresponds to the leftmost symbol of 
            <img src="/static/images/alpha.gif"> . To express that the PDA moves from
            configuration ( p , x , <img src="/static/images/alpha.gif"> ) to configuration 
            ( q , y , <img align="MIDDLE" src="/static/images/beta.gif"> ) in a single move 
            (a single application of the transition function) 
            we write 
            <br>
            ( p , x , <img src="/static/images/alpha.gif"> ) 
            
            <img src="/static/images/goto.gif">   
            
            ( q , y , <img align="MIDDLE" src="/static/images/beta.gif"> ) .
            <br>
            If ( q , y , <img align="MIDDLE" src="/static/images/beta.gif"> ) is reached from 
            ( p , x , <img src="/static/images/alpha.gif"> ) by a sequence of zero or more moves, 
            we write 
            <br>
            ( p , x , <img src="/static/images/alpha.gif"> ) 
            
            <img src="/static/images/goto.gif"><sup>*</sup>   
            
            
            ( q , y , <img align="TOP" src="/static/images/beta.gif"> ) .
            <br>
            <br>
            Let us now see how the PDA of Example 1 operates when it is given the string aabb , 
            for example.
            <br>
            Initially its configuration is ( q<sub>0</sub> , aabb , Z<sub>0</sub> ).
            After reading the first a, its configuration is  ( q<sub>0</sub> , abb , aZ<sub>0</sub> ). 
            After reading the second a, it is ( q<sub>0</sub> , bb , aaZ<sub>0</sub> ). 
            Then when the first b is read, it moves to state 
            q<sub>1</sub> and pops a from the top of the stack. Thus the configuration is
            ( q<sub>1</sub> , b , aZ<sub>0</sub> ). When the second b is read, another a is
            popped from the top of the stack and the PDA stays in state q<sub>1</sub> .
            Thus the configuration is ( q<sub>1</sub> , <img src="/static/images/Lambda.gif">  , 
            Z<sub>0</sub> ). Next it moves to the state q<sub>2</sub> which is the accepting state. 
            Thus aabb is accepted by this PDA. This entire process can be expressed using 
            the configurations as 
            <br>
            <br>
            ( q<sub>0</sub> , aabb , Z<sub>0</sub> ) <img src="/static/images/goto.gif">
            ( q<sub>0</sub> , abb , aZ<sub>0</sub> ) <img src="/static/images/goto.gif">
            ( q<sub>0</sub> , bb , aaZ<sub>0</sub> ) <img src="/static/images/goto.gif">
            ( q<sub>1</sub> , b , aZ<sub>0</sub> ) <img src="/static/images/goto.gif">
            ( q<sub>1</sub> , <img src="/static/images/Lambda.gif"> , Z<sub>0</sub> ) 
            <img src="/static/images/goto.gif"> 
            ( q<sub>2</sub> , <img src="/static/images/Lambda.gif"> , Z<sub>0</sub> ).
            <br>
            <br>
            If we are not interested in the intermediate steps, we can also write 
            <br>
            <br>
            ( q<sub>0</sub> , aabb , Z<sub>0</sub> ) <img src="/static/images/goto.gif"><sup>*</sup> 
            ( q<sub>2</sub> , <img src="/static/images/Lambda.gif"> , Z<sub>0</sub> ) .
            
            <br>
            <br>
            <font color="red"><b>A string x is accepted by a PDA</b></font>
            (a.k.a. acceptance by final state)  &nbsp; if  &nbsp;  
            (q<sub>0</sub>, x, Z<sub>0</sub>) <img src="/static/images/goto.gif"><sup>*</sup> 
            (q, <img src="/static/images/Lambda.gif">, <img src="/static/images/alpha.gif">), &nbsp; for some 
            <img src="/static/images/alpha.gif"> in <img src="/static/images/Gamma.gif"><sup>*</sup>, and
            an accepting state q. 
            <br>
            <br>
            Like FAs, PDAs can also be represented by transition diagrams. For PDAs, however, 
            arcs are labeled differently than FAs. If <img src="/static/images/delta.gif">( q , a , X ) = 
            ( p , <img src="/static/images/alpha.gif"> ) , then an arc from state p to state q is added to
            the diagram and it is labeled with ( a , X / <img src="/static/images/alpha.gif"> ) 
            indicating that X at the top of the stack is replaced by <img src="/static/images/alpha.gif">
            upon reading a from the input. 
            For example the transition diagram of the PDA of Example 1 is as shown below.
            <br>
            <br>
            <br>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
            <img src="/static/images/pda1.jpg"> 
            <br>
            <br>
            <br>
            <br>
            <b>Example 2 : </b>
            
            <br><br>
            Let us consider the pushdown automaton &lt; Q , <img src="/static/images/Sigma.gif"> ,
            <img src="/static/images/Gamma.gif"> , q<sub>0</sub> , Z<sub>0</sub> , A , 
            <img src="/static/images/delta.gif"> &gt; , where 
            Q = { q<sub>0</sub> , q<sub>1</sub> , q<sub>2</sub> } , <img src="/static/images/Sigma.gif">
            = { a , b , c } , <img src="/static/images/Gamma.gif"> = 
            { a , b , Z<sub>0</sub> } , A = { q<sub>2</sub> } and let <img src="/static/images/delta.gif"> 
            be as given in the following table:
            <br>
            <br>
            <table border="" align="center" clospan="20">
            <tbody><tr>
            <th> State </th> <th>Input</th> <th> Top of Stack </th> <th>Move</th>
            </tr>
            <tr>
            <td> q<sub>0</sub>  </td> <td>a</td> <td> Z<sub>0</sub>  </td> <td>( q<sub>0</sub> , aZ <sub>0</sub> ) </td>
            </tr>
            <tr>
            <td> q<sub>0</sub>  </td> <td>b</td> <td> Z<sub>0</sub>  </td> <td>( q<sub>0</sub> , bZ <sub>0</sub> ) </td>
            </tr>
            <tr>
            <td> q<sub>0</sub>  </td> <td>a</td> <td> <img src="/static/images/sigma.gif">   </td> <td>( q<sub>0</sub> , a<img src="/static/images/sigma.gif">  ) </td>
            </tr>
            <tr>
            <td> q<sub>0</sub>  </td> <td>b</td> <td> <img src="/static/images/sigma.gif">   </td> <td>( q<sub>0</sub> , b<img src="/static/images/sigma.gif">  ) </td>
            </tr>
            <tr>
            <td> q<sub>0</sub>  </td> <td>c</td> <td> <img src="/static/images/sigma.gif">   </td> <td>( q<sub>1</sub> , <img src="/static/images/sigma.gif">  ) </td>
            </tr>
            <tr>
            <td> q<sub>1</sub>  </td> <td>a</td> <td> a  </td> <td>( q<sub>1</sub> , <img src="/static/images/Lambda.gif">  ) </td>
            </tr>
            <tr>
            <td> q<sub>1</sub>  </td> <td>b</td> <td> b  </td> <td>( q<sub>1</sub> , <img src="/static/images/Lambda.gif"> ) </td>
            </tr>
            <tr>
            <td> q<sub>1</sub>  </td> <td><img src="/static/images/Lambda.gif"></td> <td> Z<sub>0</sub> </td> <td> ( q<sub>2</sub> , Z<sub>0</sub>  ) </td>
            </tr>
            </tbody></table>
            <br>
            <br>
            In this table <img src="/static/images/sigma.gif"> represents either a or b.
            <br>
            <br>
            This pushdown automaton accepts the language { wcw<sup>r</sup> | w 
            <img align="MIDDLE" src="/static/images/in.gif"> { a , b }<sup>*</sup> } , which is 
            the set of palindromes with c in the middle.
            <br>
            For example for the input abbcbba, it goes through the following configurations and 
            accepts it.
            <br>
            <br>
            ( q<sub>0</sub> , abbcbba , Z<sub>0</sub> ) <img src="/static/images/goto.gif">
            ( q<sub>0</sub> , bbcbba , aZ<sub>0</sub> ) <img src="/static/images/goto.gif">
            ( q<sub>0</sub> , bcbba , baZ<sub>0</sub> ) <img src="/static/images/goto.gif">
            ( q<sub>0</sub> , cbba , bbaZ<sub>0</sub> ) 
            <br>
            <img src="/static/images/goto.gif">
            ( q<sub>1</sub> , bba , bbaZ<sub>0</sub> ) <img src="/static/images/goto.gif">
            ( q<sub>1</sub> , ba , baZ<sub>0</sub> ) <img src="/static/images/goto.gif"> 
            ( q<sub>1</sub> , a , aZ<sub>0</sub> ) <img src="/static/images/goto.gif">
            ( q<sub>1</sub> , <img src="/static/images/Lambda.gif"> , Z<sub>0</sub> ) 
            <img src="/static/images/goto.gif">
            ( q<sub>2</sub> , <img src="/static/images/Lambda.gif"> , Z<sub>0</sub> ) .
            <br>
            <br>
            This PDA pushes all the a's and b's in the input into stack until c is encountered. 
            When c is detected, it ignores c and from that point on
            if the top of the stack matches the input symbol, it pops the stack.
            When there are no more unread input symbols and Z<sub>0</sub> is at the top of the stack,
            it accepts the input string. Otherwise it rejects the input string.
            <br>
            <br>
            The transition diagram of the PDA of Example 2 is as shown below.
            In the figure <img src="/static/images/sigma.gif"> ,  
            <img src="/static/images/sigma.gif"><sub>1</sub>  and 
            <img src="/static/images/sigma.gif"><sub>2</sub> represent a or b.  
            <br>
            <br>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
            <img src="/static/images/pda2.jpg"> 
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            
            <!--
            <B>PDA and Context-Free Language</B>
            <BR>
            <BR>
            There is a procedure to construct a PDA that accepts the language generated by
            a given context-free grammar and conversely. 
            That means that a language is context-free if and only if there is a PDA
            that accepts it. Those procedures are omitted here.
            <BR>
            --->
            <br>
            <br>
            <br>
            <h3>Further topics on CFL </h3>
            <br>
            <br>
            <ul>
            <li>PDA and Context-Free Language
            <br>
            <br>
            There is a procedure to construct a PDA that accepts the language generated by
            a given context-free grammar and conversely. 
            That means that a language is context-free if and only if there is a PDA
            that accepts it. Those procedures are omitted here.
            <br>
            <br>
            </li><li>Pumping Lemma for Context-Free Language
            <br>
            <br>
            Let L be a CFL. Then there is a positive integer n such that for any string u in L 
            with |u| <img align="MIDDLE" src="/static/images/geq.gif"> n , there are strings
            v, w, x, y and z which satisfy
            <br>
            <br>
            &nbsp; &nbsp; &nbsp; &nbsp; 
            u = vwxyz
            <br>
            &nbsp; &nbsp; &nbsp; &nbsp; 
            |wy| &gt; 0
            <br>
            &nbsp; &nbsp; &nbsp; &nbsp; 
            |wxy| <img align="MIDDLE" src="/static/images/leq.gif"> n
            <br>
            &nbsp; &nbsp; &nbsp; &nbsp; 
            for every integer m <img align="MIDDLE" src="/static/images/geq.gif"> 0 , 
            vw<sup>m</sup>xy<sup>m</sup>z <img align="MIDDLE" src="/static/images/in.gif"> L
            <br>
            <br>
            </li><li>Parsing and Parsers for CFL
            <br>
            <br>
            Consider the algebraic expression x + yz. Though we are accustomed to interpreting
            this as x + (yz) i.e. compute yz first, then add the result to x, it could also be
            interpreted as ( x + y )z meaning that first compute x + y, then multiply the result
            by z. Thus if a computer is given the string x + yz, it does not know which 
            interpretation to use unless it is explicitly instructed to follow one or the other.
            Similar things happen when English sentences are processed by computers (or people
            as well for that matter). For example in the sentence "A man bites a dog", native
            English speakers know that it is the dog that bites and not the other way round.
            "A dog" is the subject, "bites" is the verb and "a man" is the object of the verb.
            However, a computer like non-English speaking people must be told how to interpret 
            sentences such as the first noun phrase (" A dog") is usually the subject
            of a sentence, a verb phrase usually follow the noun phrase and the first word 
            in the verb phrase is the verb and it is followed by noun phrases reprtesenting 
            object(s) of the verb. 
            <br>
            Parsing is the process of interpreting given input strings according to predetermined
            rules i.e. productions of grammars. By parsing sentences we identify the parts of the 
            sentences and 
            determine the strutures of the sentences so that their meanings can be understood
            correctly.
            <br>
            Contect-free grammars are powerful grammars. They can describe much of programming 
            languages and basic structures of natural languages. Thus they are widely used
            for compilers for high level programming languages and natural language processing systems.
            The parsing for context-free languages and regular languages have been extensively
            studied. However, we are not going to study parsing here. Interested readers are
            referred to the textbook and other sources.
            <br>
            <br>
            ????
            <br>
            references on Parsing 
            <br>
            ????
            <br>
            <br>
            <h3><font color="green">Test Your Understanding of Contect-Free Language </font></h3>
            Indicate which of the following statements are correct and which are not.
            <br>
            Click True or Fals , then Submit.
            
            <!--
            <BR>
            There are two sets of questions.
            <BR>
            <BR>
            The following notations are used in the questions:
            <BR><BR>
            <IMG SRC="..//static/images/delta.gif">&nbsp; &nbsp;<B>:</B> \delta
            --->
            
            
            <br>
            <br>
            <br>
            <applet code="cfgex.class" width="950" height="800">
            </applet>
            <br><br>
            
            <br>
            <br>
            <br>
            
            
            
            
            
            
            <b><a href="../tm/definitions.html"><r><font color="blue">
            Next -- Turing Machines </font></r></a></b>
            <br>
            <br>
            <b>
            <a href="../schedule/schedule.html#day19"><r><font color="blue">
            Back to Schedule </font></r></a></b>
            <br>
            <br>
            <b>
            <a href="../web_course.html"><r><font color="blue">
            Back to Table of Contents </font></r></a></b>
            
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            
            
            
            <!--- Link to Proposition, Connectives --->
            
            </li></ul>
      
    {% endblock %}
  </body>
</html>